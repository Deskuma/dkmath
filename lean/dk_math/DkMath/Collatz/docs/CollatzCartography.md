# Collatz Cartography（コラッツ地図学）
>
> 「相対自己相似（花弁）」＋「ブロック比較（オフセット）」で、コラッツの“特異点（carry発火）”と“跳ね上がり”を可視化する。

## 0. 目的（Goal）

コラッツ写像は偶奇分岐により複雑に見えるが、2進（\(2\)-adic）視点では

- **花弁（\(2^k\) ブロック）**：低位 \(k\) ビットによる自己相似な区間
- **オフセット（ブロックずらし）**：上位ビットの影響（carry）を抽出する装置

として理解できる。

本ドキュメントの狙いは以下：

1. **確定部分（構造・保存則）** を Lean に形式化するための定義と補題の設計図を提供する  
2. **不確定部分（境界不等式・跳ね上がり条件）** を Python 実験で探索する計画を提供する  
3. ブロック比較により **特異点（2進 carry の発火点）** を「筋」として見えるようにする

---

## 1. 基本定義（Mathematics）

### 1.1 基本コラッツ写像

\[
C(n)=
\begin{cases}
n/2 & (2\mid n)\\
3n+1 & (2\nmid n)
\end{cases}
\]

### 1.2 加速コラッツ（奇数のみ）

奇数 \(n\) に対し

\[
s(n):=v_2(3n+1)
\]

\[
T(n):=\frac{3n+1}{2^{s(n)}} \quad (n\ \text{odd})
\]

ここで \(v_2(x)\) は「2で割れる最大指数」（2進付値）である。

### 1.3 ドリフト（膨張 vs 収縮の観測量）

m ステップでの累積割り指数

\[
S_m(n):=\sum_{i=0}^{m-1} s(n_i)
\quad (n_{i+1}=T(n_i))
\]

“3倍の膨張”と“2割りの収縮”の差（ドリフト）を

\[
D_m(n):=m\log_2 3 - S_m(n)
\]

と置く。

- \(D_m(n)>0\)：区間（その m まで）では膨張優勢＝跳ねやすい（Bad寄り）
- \(D_m(n)\le 0\)：区間（その m まで）では収縮寄り（Good寄り）

---

## 2. 花弁とオフセット（Cartography Core）

### 2.1 花弁（単位核）

単位核（花弁のサイズ）を \(B=2^k\) とし、花弁内の座標を \(r\in\{1,\dots,B\}\) とする。

### 2.2 オフセット（ブロックずらし）

ブロックずらしを

\[
\mathrm{shift}(k,m,n)=n + 2^k m
\]

と定義する。ここで \(m\) は花弁インデックス（何枚目か）に対応する。

---

## 3. 確定的核（Lean に落とすべき保存則）

### 3.1 保存則（差が出るのは特異筋だけ）

奇数 \(n\) に対し \(a=3n+1\)。ずらし後は

\[
3(n+2^k m)+1 = a + 3\cdot 2^k m
\]

**重要な事実（保存則）**：

- もし \(v_2(a)=s<k\) なら、\(v_2(a+3\cdot 2^k m)=s\) が成り立つ  
  （低位 \(k\) ビット以下では cancel できないため）
- 差が出るのは \(v_2(3n+1)\ge k\) の点（特異筋）だけ

直観：

- 花弁内の大半は “相対的に既に決まった” 模様（保存される）
- 特異筋（高桁の割れ）が、carry を通じて模様を塗り替えるイベントになる

---

## 4. Lean 形式化計画（確定部）

### 4.1 目標モジュール案

- `DkMath/Collatz/Basic.lean`
  - \(C\), `shift`, 2冪 `pow2`
- `DkMath/Collatz/V2.lean`
  - `v2Spec`（仕様）と `v2`、基本補題（割り切れ／割り切れない）
- `DkMath/Collatz/Accelerated.lean`
  - `OddNat`（奇数部分型）
  - \(s(n)=v_2(3n+1)\), \(T(n)\) の定義
- `DkMath/Collatz/ShiftInvariance.lean`
  - 保存則本体 `v2_shift_invariant`
- `DkMath/Collatz/Drift.lean`
  - \(S_m\), \(D_m\)（観測量の器：不等式自体は後で）

### 4.2 ターゲット補題（形式的主役）

> `v2_shift_invariant`  
奇数 \(n\) と \(k,m\) に対し、仮定 \(v_2(3n+1)<k\) なら  
\[
v_2(3(n+2^k m)+1)=v_2(3n+1)
\]
を示す。

---

## 5. Python 実験計画（不確定部：境界探索）

### 5.1 実験スケール（最初の標準）

- 核：\(k=8\), \(B=2^8=256\)
- 基準集合：\(r=1,\dots,B\)（奇数だけでも可）
- 花弁展開：\(j=0,\dots,B-1\)（最大 \(B^2=65536\) まで）

### 5.2 収集ログ（おすすめ）

1) 加速ログ（奇数のみ）  

- `a = 3*n + 1`
- `s = v2(a)`
- `n = a >> s`
- これを m ステップ（例：64〜512）

1) ドリフト  

- `S_m = sum(s_i)`
- `D_m ≈ m*log2(3) - S_m`
- `maxD = max_{t≤m} D_t`

1) 比較ログ（差分）
基準 `r` とずらし `r' = r + jB` の対で

- `Δs_i = s_i(r') - s_i(r)`
- `i0 = min{i | Δs_i != 0}`（ズレ初出。なければ∞）
- `ΔD_m`, `ΔmaxD`

### 5.3 可視化（最初に効く図）

- ヒートマップ：横 `r mod B`、縦 `j`、色 `i0`
  - 特異筋（\(v_2\ge k\)）が「線」として現れるはず
- `maxD` の分布（核サイズ別比較）
  - “密度は変わらないが極端値が伸びる”現象の確認

### 5.4 境界不等式候補（探索対象）

実用的な区別として、まず

- 跳ね上がり：\(\max_{t\le m} D_t(n) > B_0\)
- 収まり：\(\max_{t\le m} D_t(n) \le B_0\)

の形で \(B_0\) をスキャンし、核サイズ \(k\) 依存性を観測する。
目標は「境界 \(B_0(k,m)\) の経験則→不等式候補」を得ること。

---

## 6. 核サイズ（\(k\)）を変えたときの見え方

- 小さい \(k\)：ズレ（特異イベント）が頻発し、模様が派手（統計は取りやすいが埋もれやすい）
- 大きい \(k\)：ズレが希少になり、特異筋が鋭く浮く（解像度が上がる）

推奨セット：\(k\in\{6,7,8,9,10\}\)

---

## 7. 次のToDo（実行順）

1. Lean：`v2Spec` と `v2` の定義・基本補題整備  
2. Lean：`shift` と `v2_shift_invariant` を通す（保存則の確立）  
3. Python：\(k=8\) の `i0` ヒートマップで特異筋の視覚確認  
4. Python：`maxD` の分布・核サイズ比較 → 境界候補抽出  
5. Lean：Pythonで得た不等式“形”を命題として受け入れる器を整える  
6. 反復：核サイズを変え、頑健性（スケール不変な核）と見え方（解像度）を分離する

---

## 8. 補足（読み替え）

- 「花弁」＝ \(2^k\) ブロック（低位 \(k\) ビットが固定された区間）
- 「特異点」＝ \(v_2(3n+1)\ge k\) を満たす点（ブロック比較でズレを生む筋）
- 「跳ね上がり」＝ ドリフト \(D_m\) の部分和最大値が大きいこと（膨張優勢の連鎖）
